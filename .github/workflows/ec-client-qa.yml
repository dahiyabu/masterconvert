name: Deploy EC-Client to PROD

on:
  workflow_dispatch: # Trigger manually from GitHub UI

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Copy running Docker image from Dev Server to GitHub Actions
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST }}
          username: ${{ secrets.DEPLOY_USER }}
          key: ${{ secrets.DEPLOY_HOST_KEY }}
          passphrase: ${{ secrets.DEPLOY_HOST_KEY_PASSPHRASE }}
          script: |
            docker save ecclient:latest -o /var/tmp/ecclient.tar
            # Create the private key file for Server B
            echo "${{ secrets.DEPLOY_HOST_PROD_KEY }}" > ~/.ssh/id_rsa_target
            chmod 600 /root/.ssh/id_rsa_target
            cat <<'EOF' > /var/tmp/upload.sh
            #!/usr/bin/env bash

            # Step 1: Start ssh-agent
            eval "\$(ssh-agent -s)"

            # Step 2: Use expect to enter the passphrase
            /usr/bin/expect <<'EOT'
            set timeout 10
            set passphrase "giloysqa"
            spawn ssh-add /root/.ssh/id_rsa_target
            expect {
             -re "Enter passphrase.*:" {
             send "\$passphrase\r"
             exp_continue
            }
            eof
            }
            wait
            EOT

            # Step 3: Run your SCP command
            scp /var/tmp/ecclient.tar {{ secrets.DEPLOY_HOST_PROD_USER }}@19mn239:/var/tmp/ecclient.tar

            # Step 4: Kill the agent (optional)
            ssh-agent -k > /dev/nullQ
            EOF

            chmod +x /var/tmp/upload.sh

            # Add Server B to known_hosts to prevent prompt
            #ssh-keyscan -H ${{ secrets.DEPLOY_HOST_PROD }} >> ~/.ssh/known_hosts
  
            # Use expect to add passphrase-protected key to ssh-agent
            #  which expect || (sudo apt-get update && sudo apt-get install -y expect)
            #  eval "$(ssh-agent -s)"
              # Debug: List the contents of ~/.ssh to verify key presence
            #  echo "Listing ~/.ssh contents:"
            #  ls -l /root/.ssh/

              # Debug: Show the key file
            #  echo "Private key file content:"
            #  cat /root/.ssh/id_rsa_target
            #  echo "Manually adding key to ssh-agent..."
            #  ssh-add /root/.ssh/id_rsa_target
            #  ssh-add -l  # List keys loaded in the agent to verify
            # Use 'expect' to add passphrase-protected key to ssh-agent
            # expect << EOF
            #   spawn ssh-add /root/.ssh/id_rsa_target  # Ensure the correct absolute path
            #   expect {
            #     "Enter passphrase for /root/.ssh/id_rsa_target:" {
            #       send "${{ secrets.DEPLOY_HOST_PROD_KEY_PASSPHRASE }}\r"  # Provide the correct passphrase
            #       exp_continue
            #     }
            #     timeout {
            #       send_user "Timeout while waiting for passphrase prompt\n"
            #       exit 1
            #     }
            #     eof {
            #       send_user "Passphrase added successfully to agent\n"
            #     }
            #   }
            # EOF
            # Check if the ssh-add was successful
            #if [[ $? -eq 0 ]]; then
            #   echo "SSH key added to agent successfully."
            # else
            #   echo "Failed to add SSH key to agent."
            #   exit 1
            # fi
            # Run SCP to Server B
            #scp -i /root/.ssh/id_rsa_target -o StrictHostKeyChecking=no /var/tmp/ecclient.tar ${{ secrets.DEPLY_HOST_PROD_USER }}@${{ secrets.DEPLOY_HOST_PROD }}:/var/tmp/ecclient.tar

            #chmod 666 /var/tmp/ecclient.tar
            #echo "Docker image saved successfully."
      - name: Save base64 output to file
        run: |
          echo "${{ steps.encode-image.outputs.stdout }}" | base64 -d > ecclient.tar
      - name: Upload Docker image to Target Server
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.DEPLOY_HOST_PROD }}
          username: ${{ secrets.DEPLOY_USER_PROD }}
          key: ${{ secrets.DEPLOY_HOST_PROD_KEY }}
          passphrase: ${{ secrets.DEPLOY_HOST_PROD_KEY_PASSPHRASE }}
          source: "ecclient.tar"
          target: "/var/tmp/ecclient.tar"
      - name: Copy compose file to VPS
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.DEPLOY_HOST_PROD }}
          username: ${{ secrets.DEPLOY_USER_PROD }}
          key: ${{ secrets.DEPLOY_HOST_PROD_KEY }}
          passphrase: ${{ secrets.DEPLOY_HOST_PROD_KEY_PASSPHRASE }}
          source: "./services/client/docker-compose.yml"
          target: "~/"
      - name: Deploy Docker image on server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.DEPLOY_HOST_PROD }}
          username: ${{ secrets.DEPLOY_USER_PROD }}
          key: ${{ secrets.DEPLOY_HOST_PROD_KEY }}
          passphrase: ${{ secrets.DEPLOY_HOST_PROD_KEY_PASSPHRASE }}
          script: |
            docker network create converter-network || echo "converter-network already exists"
            
            if [[ `docker ps|grep ecclient` ]]; then
             container_id=`docker ps |grep ecclient|awk '{print $1}'`
             docker stop $container_id
             docker rm $container_id
            fi
            docker rmi ecclient:latest || echo "No old dev image found to remove"
            
            docker load -i /var/tmp/ecclient.tar
            
            sed "s#EC_APP_API_URL_VALUE#https://extconvert/api#g" ~/services/client/docker-compose.yml > ~/services/client/compose.yml
            mkdir -p /var/tmp/extconvert/logs

            
            docker compose -f ~/services/client/compose.yml up -d 2>/var/tmp/extconvert/logs/ecclient_stderr.log 1>/var/tmp/extconvert/logs/ecclient_stdout.log
            
            elapsed_time=0

            while ! docker ps | grep -q ecclient && [ $elapsed_time -lt 300 ]; do
              echo "Waiting for ecclient container to start..."
              sleep 20
              elapsed_time=$((elapsed_time + 20))
            done

            if [ $elapsed_time -ge 300 ]; then
              echo "Timeout reached! Container did not start after 300 seconds."
              rm -rf ~/services/client
              rm -rf /var/tmp/upload-ec
              exit 1  # Fail the job if the container did not start
            fi
            echo "Container is up and running!"
            
            rm -rf ~/services/client
            rm -rf /var/tmp/ecclient.tar
